import json
import websocket
from PIL import  Image
import numpy as np
import cv2
import torch
import torchvision
import FCN.sp_utils as utils
import logging
import keyboard
import os
import sys
import time
from threading import Thread
from Spine_navigation_Polyu.utils.config_robot_GUI import config
from Spine_navigation_Polyu.utils.functions import run_FCN_streamed_image,save_video, AverageMeter
#https://techtutorialsx.com/2018/11/08/python-websocket-client-sending-binary-content/

message = config.IMAGE.JSON_WS
json_mylist = json.dumps(message, separators=(',', ':'))

fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter(os.path.join(config.IMAGE.SAVE_PATH,'output_original.avi'), fourcc, 3.0, (1280, 480))  # for images of size 480*640

ws = websocket.WebSocket()
ws.connect("ws://localhost:4100")
ws.send(json_mylist)

logger = logging.getLogger()
logger.setLevel(logging.INFO)
logger.info("STARTING TEST")

class Get_Image(Thread):
    '''# we need to receive the data of length 307329'''
    def __init__(self):
        Thread.__init__(self)

        self.image = np.zeros(0)

    def run(self):
        global stop_threads  # to stop all threads at the same time
        # i = 0

        while True:
            binAnswer = ws.recv_frame()
            # print("received")
            if websocket.ABNF.OPCODE_MAP[binAnswer.opcode] == "binary":

                image_byte_array = (binAnswer.data)[129:]
                # Create a PIL Image from our pixel array.
                self.image = Image.frombuffer('L',(640, 480),image_byte_array)

                image_display = np.array(self.image)
            else:
                print("No image received")

            '''To interupt the thread '''
            if keyboard.is_pressed('c') or stop_threads==True:  # or stop_threads==True
                print("Get_Image thread is stopped")
                # ws.close()
                break


class FCN_Thread(Thread):
    '''Run FCN pre-trained model on online streamed images
    calculate the coordinate'''
    def __init__(self,Get_Image):
        Thread.__init__(self)

        self.result_im = np.zeros(0)
        self.get_image = Get_Image
        self.image_flag = False

    def run(self):
        global stop_threads  # to stop all threads at the same time
        probability = np.zeros(0)
        X = np.zeros(0)
        Y = np.zeros(0)
        num= 0
        patient = "US_probe"
        time_inference = AverageMeter()

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        if config.IMAGE.Windows == True:
            model = utils.model_pose_resnet.get_pose_net(config.IMAGE.Windows_MODEL_FILE, is_train=False)
            logger.info('=> loading model from {}'.format(config.IMAGE.Windows_MODEL_FILE))
            model.load_state_dict(
                torch.load(config.IMAGE.Windows_MODEL_FILE, map_location=torch.device('cpu'))['model_state_dict'])
            model.eval()  # Super important for testing! Otherwise the result would be random
            # logger.info("Setting model to eval. It is important for testing")
        else:
            print("Model is not defined")
            model = []

        with torch.no_grad():
            while True:
                if self.get_image.image.size: #image we get from WebSocket connection
                    # print("image received")
                    self.image_flag = True
                    start_time = time.time()
                    inputs,pred,probability, X, Y, frame_probability = run_FCN_streamed_image(self.get_image.image,model, device, probability,X,Y,logger,config)
                    # print("x",X)
                    if config.IMAGE.VIDEO == True:
                        self.result_im = save_video(out, inputs, pred, frame_probability, patient,config, target=None, labels=None)
                    #TODO: accumulate array of robot positions and force values to write it to npz file
                    time_one = time.time() - start_time
                    time_inference.update(time_one)

                else:
                    self.image_flag = False

                '''To interrupt the thread'''
                if keyboard.is_pressed('c') or stop_threads==True:
                    print("FCN_Thread stopped")

                    if time_inference.avg !=0:
                        print("fps FCN thread {}, average time per cycle {}".format(1/time_inference.avg, time_inference.avg))

                    if config.IMAGE.SAVE_NPZ_FILE:
                        while os.path.exists("FCNthread_output%s.xml" % num):
                            num += 1
                        np.savez(os.path.join(config.IMAGE.SAVE_PATH, "FCNthread_output%s.xml" % num),
                                 probability=probability, x=X, y=Y)

                    # out.release()
                    # ws.close()
                    # os._exit(0)
                    break


class Stop_Threads(Thread):
    '''# To set a flag to stop the treads. By initiating the separate thread we make sure that the keyboard
    pressed value is received immediately'''

    def __init__(self):
        Thread.__init__(self)

    def run(self):
        global stop_threads  # to stop all threads at the same time
        i = 0
        while True:
            i=+1
            if keyboard.is_pressed('c'):
                stop_threads = True  #global value
                print("Killing threads")
                break


if __name__ == '__main__':
    global stop_threads
    stop_threads = False
    try:
        thread_get_im = Get_Image()
        thread_get_im.start()
        thread_im = FCN_Thread(thread_get_im)
        thread_im.start()
        stop_threads = Stop_Threads()
        stop_threads.start()
        print("RUn")

    except KeyboardInterrupt:
        print('Hello user you have pressed ctrl-c button.')
        stop_threads = True
        time.sleep(2)
        print("closing socket and cv2 video writer")
        out.release()
        ws.close()
        os._exit(0)